"""Make `hypothesis` resolve types to the right strategies."""

from collections.abc import Callable, Iterator
from contextlib import contextmanager
from typing import TypeAlias

from hypothesis import strategies as st
from hypothesis.strategies._internal import types  # noqa: PLC2701

StrategyFactory: TypeAlias = (
    st.SearchStrategy | Callable[[type], st.SearchStrategy]
)


@contextmanager
def strategy_for_type(
    type_: type[object], strategy: StrategyFactory
) -> Iterator[None]:
    """
    Temporarily register a strategy in `hypothesis`.

    Within this context, `hypothesis` will generate data for `type_`
    using `strategy`. Otherwise, it will continue to use the globally
    registered strategy for `type_`.

    NOTE: This manually adds and removes strategies from an internal data
    structure of `hypothesis`: `types._global_type_lookup`. This is a global
    variable used for practically every example generated by `hypothesis`, so
    we can easily have unintentional side-effects. We have to be very careful
    when modifying it.
    """
    previous_strategy = types._global_type_lookup.pop(type_, None)  # noqa: SLF001
    st.register_type_strategy(type_, strategy)

    try:
        yield
    finally:
        types._global_type_lookup.pop(type_)  # noqa: SLF001
        if previous_strategy is None:
            _clean_caches()
        else:
            st.register_type_strategy(type_, previous_strategy)


def look_up_strategy(
    type_: type[object],
) -> StrategyFactory | None:
    """Return the strategy used by `hypothesis`."""
    return types._global_type_lookup.get(type_)  # noqa: SLF001


def apply_strategy(
    strategy: StrategyFactory, type_: type[object]
) -> StrategyFactory:
    """Apply `strategy` to `type_`."""
    if isinstance(strategy, st.SearchStrategy):
        return strategy
    return strategy(type_)


def _clean_caches() -> None:
    st.from_type.__clear_cache()  # type: ignore[attr-defined]  # noqa: SLF001
