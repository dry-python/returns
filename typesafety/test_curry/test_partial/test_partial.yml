- case: partial_zero_args
  disable_cache: false
  main: |
    from returns.curry import partial

    def two_args(first: int, second: float) -> str:
        ...

    reveal_type(partial(two_args))  # N: Revealed type is "def (first: builtins.int, second: builtins.float) -> builtins.str"


- case: partial_single_arg
  disable_cache: false
  main: |
    from returns.curry import partial

    def two_args(first: int, second: float) -> str:
        ...

    reveal_type(partial(two_args, 1))  # N: Revealed type is "def (second: builtins.float) -> builtins.str"


- case: partial_all_args
  disable_cache: false
  main: |
    from returns.curry import partial

    def two_args(first: int, second: float) -> str:
        ...

    reveal_type(partial(two_args, 1, second=0.5))  # N: Revealed type is "def () -> builtins.str"


- case: partial_single_named_arg
  disable_cache: false
  main: |
    from returns.curry import partial

    def two_args(first: int, second: float) -> str:
        ...

    reveal_type(partial(two_args, second=1.0))  # N: Revealed type is "def (first: builtins.int) -> builtins.str"


- case: partial_multiple_args
  disable_cache: false
  main: |
    from returns.curry import partial

    def multiple(
        first: int,
        second: float,
        third: str,
        flag1: bool,
        flag2: bool,
        flag3: type,
    ) -> str:
        ...

    reveal_type(partial(multiple, 1, 0.4, flag3=int, flag2=True))  # N: Revealed type is "def (third: builtins.str, flag1: builtins.bool) -> builtins.str"


- case: partial_not_callable_type
  disable_cache: false
  main: |
    from returns.curry import partial

    curried_int = partial(int, 10)

    reveal_type(curried_int)  # N: Revealed type is "def () -> builtins.int"


- case: partial_explicit_noreturn
  disable_cache: false
  main: |
    from returns.curry import partial
    from typing import NoReturn

    def exit(x: int) -> NoReturn:
        ...

    reveal_type(partial(exit, 1))  # N: Revealed type is "def () -> Never"


- case: partial_wrong_argument_types
  disable_cache: false
  main: |
    from returns.curry import partial
    from typing_extensions import Literal

    def multiple(
        first: int,
        second: float,
        flag: Literal[True],
    ) -> str:
        ...

    partial(multiple, 'a', flag=False)
  out: |
    main:11: error: Argument 1 to "multiple" has incompatible type "str"; expected "int"  [arg-type]
    main:11: error: Argument 2 to "multiple" has incompatible type "bool"; expected "Literal[True]"  [arg-type]


- case: partial_too_many_positional_args
  disable_cache: false
  main: |
    from returns.curry import partial
    from typing_extensions import Literal

    def multiple(
        first: int,
        second: float,
    ) -> str:
        ...

    x = partial(multiple, 1, 2.0, 3)
  out: |
    main:10: error: Too many arguments for "multiple"  [call-arg]


- case: partial_invalid_named_arg
  disable_cache: false
  main: |
    from returns.curry import partial
    from typing_extensions import Literal

    def multiple(
        first: int,
        second: float,
    ) -> str:
        ...

    partial(multiple, missing=1)
  out: |
    main:4: note: "multiple" defined here
    main:10: error: Unexpected keyword argument "missing" for "multiple"  [call-arg]


- case: partial_regression618
  disable_cache: false
  main: |
    from typing import Callable, TypeVar
    from returns.curry import partial

    _FirstType = TypeVar('_FirstType')
    _SecondType = TypeVar('_SecondType')

    def test(
        default: _SecondType,
        function: Callable[[_SecondType, _FirstType], _SecondType],
    ):
        reveal_type(partial(function, default))  # N: Revealed type is "def (_FirstType`-2) -> _SecondType`-1"


- case: partial_regression1711
  disable_cache: false
  main: |
    from returns.curry import partial

    def foo(x: int, y: int, z: int) -> int:
        ...

    def bar(x: int) -> int:
        ...

    baz = partial(foo, bar(1))
    reveal_type(baz)  # N: Revealed type is "def (y: builtins.int, z: builtins.int) -> builtins.int"


- case: partial_optional_arg
  disable_cache: false
  main: |
    from returns.curry import partial

    def test_partial_fn(
        first_arg: int,
        optional_arg: str | None,
    ) -> tuple[int, str | None]:
        ...

    bound = partial(test_partial_fn, 1)
    reveal_type(bound)  # N: Revealed type is "def (optional_arg: builtins.str | None) -> tuple[builtins.int, builtins.str | None]"


- case: partial_decorator
  disable_cache: false
  main: |
    from returns.curry import partial

    @partial(first=1)
    def _decorated(first: int, second: str) -> float:
        ...

    reveal_type(_decorated)  # N: Revealed type is "Any"
  out: |
    main:3: error: Untyped decorator makes function "_decorated" untyped  [misc]


- case: partial_keyword_arg
  disable_cache: false
  main: |
    from returns.curry import partial

    def test_partial_fn(
        first_arg: int,
        optional_arg: str | None,
    ) -> tuple[int, str | None]:
        ...

    bound = partial(test_partial_fn, optional_arg='a')
    reveal_type(bound)  # N: Revealed type is "def (first_arg: builtins.int) -> tuple[builtins.int, builtins.str | None]"


- case: partial_keyword_only
  disable_cache: false
  main: |
    from returns.curry import partial

    def _target(*, arg: int) -> int:
        ...

    bound = partial(_target, arg=1)
    reveal_type(bound)  # N: Revealed type is "def () -> builtins.int"


- case: partial_keyword_mixed
  disable_cache: false
  main: |
    from returns.curry import partial

    def _target(arg1: int, *, arg2: int) -> int:
        ...

    bound = partial(_target, arg2=1)
    reveal_type(bound)  # N: Revealed type is "def (arg1: builtins.int) -> builtins.int"


- case: partial_wrong_signature_any
  disable_cache: false
  main: |
    from returns.curry import partial

    reveal_type(partial(len, 1))
  out: |
    main:3: error: Argument 1 to "len" has incompatible type "int"; expected "Sized"  [arg-type]
    main:3: note: Revealed type is "def (*Any, **Any) -> builtins.int"
