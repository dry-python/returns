- case: maybe_from_value1
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    value: int
    reveal_type(Maybe.from_value(value))  # N: Revealed type is 'returns.maybe.Maybe[builtins.int*]'


- case: maybe_from_value2
  disable_cache: true
  main: |
    from typing import Optional
    from returns.maybe import Maybe

    value: Optional[int]
    reveal_type(Maybe.from_value(value))  # N: Revealed type is 'returns.maybe.Maybe[Union[builtins.int, None]]'


- case: maybe_from_optional1
  disable_cache: true
  main: |
    from typing import Optional
    from returns.maybe import Maybe

    value: int
    reveal_type(Maybe.from_optional(value))  # N: Revealed type is 'returns.maybe.Maybe[builtins.int*]'


- case: maybe_from_optional2
  disable_cache: true
  main: |
    from typing import Optional
    from returns.maybe import Maybe

    value: Optional[int]
    reveal_type(Maybe.from_optional(value))  # N: Revealed type is 'returns.maybe.Maybe[builtins.int*]'


- case: maybe_from_iterable1
  disable_cache: true
  main: |
    from returns.maybe import Maybe
    from typing import Iterable

    x: Iterable[Maybe[int]]

    reveal_type(Maybe.from_iterable(x))  # N: Revealed type is 'returns.maybe.Maybe[typing.Sequence[builtins.int*]]'


- case: maybe_from_iterable2
  disable_cache: true
  main: |
    from returns.maybe import Maybe
    from returns.primitives.iterables import CollectAll
    from typing import Iterable

    x: Iterable[Maybe[int]]

    reveal_type(Maybe.from_iterable(x, CollectAll))  # N: Revealed type is 'returns.maybe.Maybe[typing.Sequence[builtins.int*]]'


- case: maybe_map_regular
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    result = Maybe.from_value(1).map(lambda i: i / i)
    reveal_type(result)  # N: Revealed type is 'returns.maybe.Maybe[builtins.float*]'


- case: maybe_map_optional1
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    result = Maybe.from_value({'a': 'b'}).map(lambda d: d.get('a', None))
    reveal_type(result)  # N: Revealed type is 'returns.maybe.Maybe[Union[builtins.str, None]]'


- case: maybe_map_optional2
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    result = Maybe.from_value(1).bind(lambda d: Maybe.from_value(str(d)))
    reveal_type(result)  # N: Revealed type is 'returns.maybe.Maybe[builtins.str*]'


- case: maybe_apply
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    result = Maybe.from_value(1).apply(Maybe.from_value(float))
    reveal_type(result)  # N: Revealed type is 'returns.maybe.Maybe[builtins.float*]'


- case: maybe_bind1
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    def test(arg: int) -> Maybe[str]:
        ...

    reveal_type(Maybe.from_value(1).bind(test))  # N: Revealed type is 'returns.maybe.Maybe[builtins.str*]'


- case: maybe_bind2
  disable_cache: true
  main: |
    from returns.maybe import Maybe
    from typing import Optional

    def test(arg: int) -> Maybe[Optional[str]]:
        ...

    reveal_type(Maybe.from_value(1).bind(test))  # N: Revealed type is 'returns.maybe.Maybe[Union[builtins.str, None]]'


- case: maybe_bind_optional
  disable_cache: true
  main: |
    from returns.maybe import Maybe
    from typing import Optional

    def test(arg: int) -> Optional[str]:
        ...

    reveal_type(Maybe.from_value(1).bind_optional(test))  # N: Revealed type is 'returns.maybe.Maybe[builtins.str*]'


- case: maybe_value_or
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    result = Maybe.from_value(1).value_or(None)
    reveal_type(result)  # N: Revealed type is 'Union[builtins.int, None]'


- case: maybe_or_else1
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    result = Maybe.from_value(1).or_else_call(lambda: 2)
    reveal_type(result)  # N: Revealed type is 'builtins.int'


- case: maybe_or_else2
  disable_cache: true
  main: |
    from returns.maybe import Maybe

    def fallback() -> str:
        ...

    result = Maybe.from_value(1).or_else_call(fallback)
    reveal_type(result)  # N: Revealed type is 'Union[builtins.int, builtins.str*]'


- case: maybe_or_else3
  disable_cache: true
  main: |
    from returns.maybe import Maybe
    from typing import NoReturn

    def fallback() -> NoReturn:
        ...

    result = Maybe.from_value(1).or_else_call(fallback)
    reveal_type(result)  # N: Revealed type is 'builtins.int'


- case: maybe_unwrap
  disable_cache: true
  main: |
    from returns.maybe import Some

    reveal_type(Some(1).unwrap())  # N: Revealed type is 'builtins.int*'
