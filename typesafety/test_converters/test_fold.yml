- case: fold_result
  disable_cache: true
  main: |
    from returns.converters import fold_result
    from returns.result import Result

    def first(arg: int) -> float:
        ...

    def second(arg: str) -> float:
        ...

    container: Result[int, str]
    reveal_type(fold_result(first, second)(container))  # N: Revealed type is 'builtins.float*'


- case: fold_ioresult_correct
  disable_cache: true
  main: |
    from returns.converters import fold_ioresult
    from returns.io import IO, IOResult

    def first(arg: int) -> IO[float]:
        ...

    def second(arg: str) -> IO[float]:
        ...

    container: IOResult[int, str]
    reveal_type(fold_ioresult(first, second)(container))  # N: Revealed type is 'returns.io.IO[builtins.float*]'


- case: fold_ioresult_wrong
  disable_cache: true
  main: |
    from returns.converters import fold_ioresult
    from returns.io import IO, IOResult

    def first(arg: int) -> float:
        ...

    def second(arg: str) -> float:
        ...

    container: IOResult[int, str]
    fold_ioresult(first, second)(container)
  out: |
    main:11: error: Argument 1 has incompatible type "Callable[[int], float]"; expected "Callable[[int], IO[<nothing>]]" (diff)
    main:11: error: Argument 2 has incompatible type "Callable[[str], float]"; expected "Callable[[str], IO[<nothing>]]"


- case: fold_maybe
  disable_cache: true
  main: |
    from returns.converters import fold_maybe
    from returns.maybe import Maybe

    def first(arg: int) -> float:
        ...

    def second(_) -> float:
        ...

    container: Maybe[int]
    reveal_type(fold_maybe(first, second)(container))  # N: Revealed type is 'builtins.float*'
